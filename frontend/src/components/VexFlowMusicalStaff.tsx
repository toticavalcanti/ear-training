// src/components/VexFlowMusicalStaff.tsx - CORRE√á√ÉO DAS ENARMONIAS
// ‚úÖ CORRE√á√ÉO: midiToVexFlowKey agora respeita a tonalidade
// ‚úÖ F menor usa bem√≥is (Db, Ab) em vez de sustenidos (C#, G#)

"use client";

import React, {
  useRef,
  useState,
  useMemo,
  useCallback,
  useEffect,
} from "react";

// ========================================
// INTERFACES E TIPOS (MANTIDOS)
// ========================================

interface HarmonicAnalysis {
  symbol: string;
  degree: string;
  analysis: string;
  voicing: number[];
}

interface VexFlowMusicalStaffProps {
  progression: HarmonicAnalysis[];
  title?: string;
  timeSignature?: string;
  showChordSymbols?: boolean;
  showRomanNumerals?: boolean;
  chordSymbols?: string[];
}

// ========================================
// TIPAGEM RIGOROSA PARA VEXFLOW v5.0.0
// ========================================

interface VexFlowContext {
  setFont(font: string): this;
  fillText(text: string, x: number, y: number): void;
}

interface VexFlowStave {
  setContext(context: VexFlowContext): this;
  addClef(clef: string): this;
  addTimeSignature(sig: string): this;
  addKeySignature(key: string): this;
  draw(): void;
}

interface VexFlowStaveNote {
  clef?: "treble" | "bass";
  addModifier(modifier: object, index?: number): this;
}

interface VexFlowVoice {
  addTickables(notes: VexFlowStaveNote[]): this;
  draw(context: VexFlowContext, stave: VexFlowStave): void;
  getTickables(): VexFlowStaveNote[];
}

interface VexFlowFormatter {
  joinVoices(voices: VexFlowVoice[]): this;
  format(voices: VexFlowVoice[], width: number): this;
}

interface VexFlowStaveConstructor {
  new (x: number, y: number, width: number): VexFlowStave;
}

interface VexFlowStaveNoteConstructor {
  new (note: {
    keys: string[];
    duration: string;
    clef?: "treble" | "bass";
  }): VexFlowStaveNote;
}

interface VexFlowVoiceConstructor {
  new (spec: { num_beats: number; beat_value: number }): VexFlowVoice;
}

interface VexFlowFormatterConstructor {
  new (): VexFlowFormatter;
}

interface VexFlowAccidentalConstructor {
  new (type: string): object;
}

interface VexFlowRendererConstructor {
  new (element: HTMLElement, backend: number): {
    resize(width: number, height: number): void;
    getContext(): VexFlowContext;
  };
  Backends: { SVG: number };
}

declare global {
  interface Window {
    VexFlow?: {
      Renderer: VexFlowRendererConstructor;
      Stave: VexFlowStaveConstructor;
      StaveNote: VexFlowStaveNoteConstructor;
      Voice: VexFlowVoiceConstructor;
      Formatter: VexFlowFormatterConstructor;
      Accidental: VexFlowAccidentalConstructor;
    };
  }
}

// ========================================
// üéº COMPONENTE PRINCIPAL
// ========================================
const VexFlowMusicalStaff: React.FC<VexFlowMusicalStaffProps> = ({
  progression,
  title = "Progress√£o Harm√¥nica",
  timeSignature,
  showChordSymbols = true,
  showRomanNumerals = false,
  chordSymbols,
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [isVexFlowLoaded, setIsVexFlowLoaded] = useState(false);

  // Detec√ß√£o de tonalidade
  const detectedKey = useMemo((): string => {
    if (!progression || progression.length === 0) return "C";

    console.log("üîç VexFlow detectedKey - Analisando:", title);

    const titleLower = title.toLowerCase();

    // ‚úÖ CORRE√á√ÉO: Detec√ß√£o mais precisa baseada no t√≠tulo

    // Procurar por padr√£o "- [KEY]" no t√≠tulo
    const keyMatch = title.match(/- ([A-G][b#]?)\s*$/);
    if (keyMatch) {
      const extractedKey = keyMatch[1];
      console.log(
        `‚úÖ VexFlow: Tonalidade extra√≠da do t√≠tulo: "${extractedKey}"`
      );
      return extractedKey;
    }

    // Fallback para detec√ß√£o manual (m√©todo antigo como backup)
    if (titleLower.includes("- db") || titleLower.includes("-db")) {
      console.log("‚úÖ VexFlow: Detectado Db (bemol)");
      return "Db";
    }
    if (
      titleLower.includes("- d ") ||
      titleLower.includes("-d ") ||
      titleLower.endsWith("- d")
    ) {
      console.log("‚úÖ VexFlow: Detectado D (natural)");
      return "D";
    }
    if (titleLower.includes("- eb") || titleLower.includes("-eb")) {
      console.log("‚úÖ VexFlow: Detectado Eb");
      return "Eb";
    }
    if (
      titleLower.includes("- e ") ||
      titleLower.includes("-e ") ||
      titleLower.endsWith("- e")
    ) {
      console.log("‚úÖ VexFlow: Detectado E");
      return "E";
    }

    // ‚úÖ CORRE√á√ÉO ESPEC√çFICA: Para "Blues Grant Green Bebop - Db"
    if (titleLower.includes("grant green") && titleLower.includes("db")) {
      console.log("‚úÖ VexFlow: Grant Green em Db confirmado");
      return "Db";
    }

    console.log("‚ö†Ô∏è VexFlow: Tonalidade n√£o detectada, usando C como padr√£o");
    return "C";
  }, [progression, title]);

  const stableProgression = useMemo(() => progression || [], [progression]);
  const stableChordSymbols = useMemo(
    () => chordSymbols || progression.map((p) => p.symbol),
    [chordSymbols, progression]
  );
  const progressionTimeSignature = useMemo(
    () => timeSignature || "4/4",
    [timeSignature]
  );

  // ========================================
  // üêõ DEBUG DO MIDI RECEBIDO
  // ========================================
  useEffect(() => {
    if (progression && progression.length > 0) {
      console.log("\nüéØ === MIDI RECEBIDO DO SISTEMA ===");
      console.log("üìù T√≠tulo:", title);
      console.log("üéµ Total de acordes:", progression.length);

      progression.forEach((chord, index) => {
        console.log(`\nüéπ === ACORDE ${index + 1} ===`);
        console.log(`   üéº Grau:`, chord.degree);
        console.log(`   üéµ Cifra:`, stableChordSymbols[index]);
        console.log(`   üéπ MIDI:`, chord.voicing);

        // An√°lise das notas
        chord.voicing.forEach((midi, noteIndex) => {
          const octave = Math.floor(midi / 12) - 1;
          const noteIndex12 = midi % 12;
          const noteNames = [
            "C",
            "C#",
            "D",
            "D#",
            "E",
            "F",
            "F#",
            "G",
            "G#",
            "A",
            "A#",
            "B",
          ];
          const noteName = noteNames[noteIndex12];
          console.log(
            `      üìç ${noteIndex + 1}. MIDI ${midi} = ${noteName}${octave}`
          );
        });
      });

      console.log("üéØ === FIM DEBUG ===\n");
    }
  }, [progression, title, stableChordSymbols]);

  // ========================================
  // üéµ CONVERS√ÉO MIDI PARA VEXFLOW - CORRIGIDA
  // ========================================
  const midiToVexFlowKey = useCallback(
    (midi: number): string => {
      const octave = Math.floor(midi / 12) - 1;
      const noteIndex = midi % 12;

      const flatKeys = ["F", "Bb", "Eb", "Ab", "Db", "Gb", "Cb"];
      const useFlats = flatKeys.includes(detectedKey);

      const sharpNames = [
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#",
        "A",
        "A#",
        "B",
      ];
      const flatNames = [
        "C",
        "Db",
        "D",
        "Eb",
        "E",
        "F",
        "Gb",
        "G",
        "Ab",
        "A",
        "Bb",
        "B",
      ];

      // ‚úÖ L√ìGICA INTELIGENTE: Baseada na tonalidade E contexto harm√¥nico
      let noteName: string;

      if (noteIndex === 10) {
        // A#/Bb
        // Bb em: tonalidades com bem√≥is OU acordes dominantes (C7, F7, etc.)
        // A# em: tonalidades com sustenidos E contexto de sens√≠vel (B7, C#7, etc.)
        if (useFlats || detectedKey === "C" || detectedKey === "G") {
          noteName = "Bb"; // Para C7, F7, progress√µes em bem√≥is
        } else {
          noteName = "A#"; // Para B7, C#7, progress√µes em sustenidos
        }
      } else if (noteIndex === 3) {
        // D#/Eb
        if (useFlats || detectedKey === "G") {
          noteName = "Eb"; // bVI em G, acordes em bem√≥is
        } else {
          noteName = "D#"; // Em tonalidades com sustenidos
        }
      } else if (noteIndex === 8) {
        // G#/Ab
        noteName = useFlats ? "Ab" : "G#";
      } else if (noteIndex === 1) {
        // C#/Db
        noteName = useFlats ? "Db" : "C#";
      } else if (noteIndex === 6) {
        // F#/Gb
        noteName = useFlats ? "Gb" : "F#";
      } else {
        const noteNames = useFlats ? flatNames : sharpNames;
        noteName = noteNames[noteIndex];
      }

      const result = `${noteName}/${octave}`;
      console.log(`üéµ MIDI ${midi} ‚Üí ${result} (${detectedKey})`);
      return result;
    },
    [detectedKey]
  );

  // Fun√ß√£o para carregar VexFlow
  const loadVexFlow = useCallback(() => {
    if (window.VexFlow) {
      setIsVexFlowLoaded(true);
      return;
    }
    const script = document.createElement("script");
    script.src =
      "https://cdn.jsdelivr.net/npm/vexflow@5.0.0/build/cjs/vexflow.js";
    script.async = true;
    script.onload = () => setIsVexFlowLoaded(true);
    script.onerror = () => console.error("Erro ao carregar VexFlow");
    document.head.appendChild(script);
  }, []);

  // ========================================
  // üéº RENDERIZA√á√ÉO FIEL AO MIDI
  // ========================================
  const renderWithVexFlow = useCallback(() => {
    const VF = window.VexFlow;
    if (!VF || !containerRef.current || stableProgression.length === 0) {
      console.warn("VexFlow n√£o carregado ou progress√£o vazia");
      return;
    }

    const container = containerRef.current;
    container.innerHTML = "";

    try {
      const renderer = new VF.Renderer(container, VF.Renderer.Backends.SVG);
      const containerWidth = container.clientWidth;
      const measuresPerLine = Math.min(
        4,
        Math.max(2, Math.floor(containerWidth / 280))
      );
      const numLines = Math.ceil(stableProgression.length / measuresPerLine);
      const systemHeight = 200;
      const systemSpacing = 40;

      const totalHeight =
        numLines * systemHeight + (numLines - 1) * systemSpacing + 40;
      renderer.resize(containerWidth, totalHeight);
      const context = renderer.getContext();

      stableProgression.forEach((chord, i) => {
        const lineIndex = Math.floor(i / measuresPerLine);
        const measureIndexInLine = i % measuresPerLine;
        const measureWidth = Math.floor(
          (containerWidth - 20) / measuresPerLine
        );

        const x = 10 + measureIndexInLine * measureWidth;
        const y = 30 + lineIndex * (systemHeight + systemSpacing);

        // Pentagramas
        const trebleStave = new VF.Stave(x, y, measureWidth);
        const bassStave = new VF.Stave(x, y + 90, measureWidth);

        if (measureIndexInLine === 0) {
          trebleStave
            .addClef("treble")
            .addTimeSignature(progressionTimeSignature)
            .addKeySignature(detectedKey);

          bassStave
            .addClef("bass")
            .addTimeSignature(progressionTimeSignature)
            .addKeySignature(detectedKey);
        }

        trebleStave.setContext(context).draw();
        bassStave.setContext(context).draw();

        // ========================================
        // üîç DEBUG: RASTREAMENTO DA NOTA FANTASMA REMOVIDO
        // ========================================
        console.log(`\nüîç === RENDERIZANDO ${stableChordSymbols[i]} ===`);
        console.log(`   üéπ MIDI original:`, chord.voicing);

        // ‚úÖ USAR EXATAMENTE O MIDI TOCADO
        const exactMidiNotes = [...chord.voicing].sort((a, b) => a - b);
        const adjustedNotes = exactMidiNotes;

        console.log(`   ‚úÖ MIDI final:`, adjustedNotes);

        // Divis√£o entre claves (C4 = MIDI 60)
        const bassNotes = adjustedNotes.filter((note) => note < 60);
        const trebleNotes = adjustedNotes.filter((note) => note >= 60);

        console.log(`   üéº Bass (< C4):`, bassNotes);
        console.log(`   üéº Treble (>= C4):`, trebleNotes);

        // ========================================
        // üîç DEBUG: VERIFICAR CONVERS√ÉO PARA VEXFLOW COM ENARMONIAS CORRETAS
        // ========================================
        if (bassNotes.length > 0) {
          console.log(`üîç Convers√£o Bass para VexFlow (${detectedKey}):`);
          bassNotes.forEach((midi) => {
            const vexKey = midiToVexFlowKey(midi);
            console.log(`   MIDI ${midi} ‚Üí VexFlow "${vexKey}"`);
          });
        }

        if (trebleNotes.length > 0) {
          console.log(`üîç Convers√£o Treble para VexFlow (${detectedKey}):`);
          trebleNotes.forEach((midi) => {
            const vexKey = midiToVexFlowKey(midi);
            console.log(`   MIDI ${midi} ‚Üí VexFlow "${vexKey}"`);
          });
        }

        const voices: VexFlowVoice[] = [];

        // Clave de sol
        if (trebleNotes.length > 0) {
          const trebleVexKeys = trebleNotes.map(midiToVexFlowKey);
          console.log(`   üéµ Treble keys:`, trebleVexKeys);

          const trebleNote = new VF.StaveNote({
            keys: trebleVexKeys,
            duration: "w",
            clef: "treble",
          });

          trebleVexKeys.forEach((key, index) => {
            const noteName = key.split("/")[0];
            const baseNote = noteName.charAt(0); // Ex: 'D' de 'D/5'

            // Verificar se precisa de bequadro
            const keyAccidentals = ["F#", "C#", "G#", "D#"]; // Para E maior
            const needsNatural =
              keyAccidentals.some((acc) => acc.charAt(0) === baseNote) &&
              !noteName.includes("#") &&
              !noteName.includes("b");

            if (needsNatural) {
              try {
                const accidental = new VF.Accidental("n");
                trebleNote.addModifier(accidental, index);
                console.log(`üéµ Bequadro ‚ôÆ aplicado em ${key}`);
              } catch (error) {
                console.warn(`‚ö†Ô∏è Erro ao aplicar ‚ôÆ:`, error);
              }
            } else if (noteName.includes("b")) {
              try {
                const accidental = new VF.Accidental("b");
                trebleNote.addModifier(accidental, index);
                console.log(`üéµ Acidente ‚ô≠ aplicado em ${key}`);
              } catch (error) {
                console.warn(`‚ö†Ô∏è Erro ao aplicar ‚ô≠:`, error);
              }
            } else if (noteName.includes("#")) {
              try {
                const accidental = new VF.Accidental("#");
                trebleNote.addModifier(accidental, index);
                console.log(`üéµ Acidente # aplicado em ${key}`);
              } catch (error) {
                console.warn(`‚ö†Ô∏è Erro ao aplicar #:`, error);
              }
            }
          });

          const trebleVoice = new VF.Voice({ num_beats: 4, beat_value: 4 });
          trebleVoice.addTickables([trebleNote]);
          voices.push(trebleVoice);
        }

        // Clave de f√°
        if (bassNotes.length > 0) {
          const bassVexKeys = bassNotes.map(midiToVexFlowKey);
          console.log(`   üéµ Bass keys:`, bassVexKeys);

          const bassNote = new VF.StaveNote({
            keys: bassVexKeys,
            duration: "w",
            clef: "bass",
          });

          const bassVoice = new VF.Voice({ num_beats: 4, beat_value: 4 });
          bassVoice.addTickables([bassNote]);
          voices.push(bassVoice);
        }

        // Renderizar
        if (voices.length > 0) {
          const formatter = new VF.Formatter().joinVoices(voices);
          formatter.format(voices, measureWidth * 0.75);

          voices.forEach((voice) => {
            const firstNote = voice.getTickables()[0] as VexFlowStaveNote;
            const targetStave =
              firstNote.clef === "treble" ? trebleStave : bassStave;
            voice.draw(context, targetStave);
          });

          console.log(
            `   ‚úÖ ${stableChordSymbols[i]} renderizado com enarmonias corretas!`
          );
        }

        // S√≠mbolos dos acordes
        context.setFont("14px Arial");
        if (showChordSymbols && stableChordSymbols[i]) {
          context.fillText(stableChordSymbols[i], x + 10, y - 10);
        }
        if (showRomanNumerals) {
          context.setFont("12px Arial");
          context.fillText(chord.degree, x + 10, y + 190);
        }
      });
    } catch (error) {
      console.error("Erro ao renderizar com VexFlow:", error);
    }
  }, [
    stableProgression,
    progressionTimeSignature,
    detectedKey,
    stableChordSymbols,
    showChordSymbols,
    showRomanNumerals,
    midiToVexFlowKey,
  ]);

  // Fun√ß√£o para convers√£o MIDI para nome (debug)
  const midiToName = useCallback((midi: number): string => {
    const noteNames = [
      "C",
      "C#",
      "D",
      "D#",
      "E",
      "F",
      "F#",
      "G",
      "G#",
      "A",
      "A#",
      "B",
    ];
    const octave = Math.floor(midi / 12) - 1;
    const noteIndex = midi % 12;
    return `${noteNames[noteIndex]}${octave}`;
  }, []);

  // Effects
  useEffect(() => {
    loadVexFlow();
  }, [loadVexFlow]);

  useEffect(() => {
    if (isVexFlowLoaded && stableProgression.length > 0) {
      const timeoutId = setTimeout(renderWithVexFlow, 150);

      const handleResize = () => {
        clearTimeout(timeoutId);
        setTimeout(renderWithVexFlow, 150);
      };

      window.addEventListener("resize", handleResize);

      return () => {
        clearTimeout(timeoutId);
        window.removeEventListener("resize", handleResize);
      };
    }
  }, [isVexFlowLoaded, renderWithVexFlow, stableProgression.length]);

  return (
    <div className="w-full bg-white rounded-xl shadow-lg">
      <div className="px-6 py-4 border-b">
        <h3 className="font-bold text-lg">{title}</h3>
        <p className="text-sm text-gray-600">
          {stableProgression.length} acordes ‚Ä¢ {progressionTimeSignature} ‚Ä¢
          Tonalidade: {detectedKey}
        </p>
      </div>

      <div className="p-4">
        {!isVexFlowLoaded && (
          <div className="flex justify-center items-center h-32">
            <div className="text-gray-500">Carregando nota√ß√£o musical...</div>
          </div>
        )}
        <div ref={containerRef} className="w-full overflow-x-auto" />
      </div>

      <div className="px-6 py-4 border-t">
        <h4 className="font-bold mb-4">An√°lise Detalhada dos Acordes:</h4>
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {stableProgression.map((chord, index) => (
            <div
              key={`${stableChordSymbols[index]}-${index}`}
              className="p-3 rounded-lg border bg-gray-50 text-sm"
            >
              <p className="font-bold mb-2">{stableChordSymbols[index]}</p>
              <p>
                <strong>Notas MIDI:</strong> {chord.voicing.join(", ")}
              </p>
              <p>
                <strong>Notas:</strong>{" "}
                {chord.voicing.map(midiToName).join(", ")}
              </p>
              <p>
                <strong>Grau:</strong> {chord.degree}
              </p>
              <p>
                <strong>Fun√ß√£o:</strong> {chord.analysis}
              </p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default VexFlowMusicalStaff;
